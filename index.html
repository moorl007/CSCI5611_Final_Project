<html>
    <body>
        <h1> CSCI 5611 Final Project</h1>
        <h1>Ben Moorlach</h1>

        <h2>Final State</h2>

            <p>
                The goal of my project was to create a maze where all of the walls, floor, and ceiling were white, meaning the user could not see where they were.  In order to navigate the maze, the user would be able to shoot shoot black particles which will stick to the surfaces of the maze and they can use the arrow keys to navigate to the exit.  I also wanted to be able to generate a different maze each time so the user could have a new experience every time they played.  The user starts in the top-left corner of an orthogonal maze and can use the arrow keys and WASD keys to navigate.  The user can also press the space bar to shoot particles in the diection they are facing.  Once the user finds the exit, they realize that the maze was just a large room and the outside of the room is very beautiful.
            </p>


        <h2>Initial Sketch</h2>

            <p>
                My final product turned out to be pretty close to what I had initially envisioned. Which is shown below:
            </p>
            
            <figure>
                <img src="initialsketch.png" alt="Proposed sketch of my final project" width = 800 height = 450>
                <figcaption>Proposed sketch of my final project</figcaption>
            </figure>





        <h2>Algorithms and Approaches</h2>

            <h3>Maze Generation</h3>
                <p>
                    My first problem I needed to solve was randomly generating a maze.  I thought a good idea would be to have a 20 by 20 grid, and select some of those blocks to be walls, and allow the user walk and move in the spaces that weren’t walls.
                </p>

                <figure>
                    <img src="20by20.png" alt="A 20 by 20 grid which will be the basis of my maze" width = 500 height = 500>
                    <figcaption>A 20 by 20 grid which will be the basis of my maze</figcaption>
                </figure>

                <p>
                    I will demonstrate further with an 8 by 8 grid. 
                    
                    <br>
                    <br>

                    Initially, every other row and every other column are filled in, meaning they are walls.  The user starts in the upper left corner of the grid, so that’s where our algorithm will start.  This initial cell has unvisited neighbors to the right and beneath it.  

                </p>

                <figure>
                    <img src="maze2.png" alt="An 8 by 8 grid where every other row and every other column are walls.  The starting cell is in the upper left, and it has a neighbor to the right and a neighbor beneath." width = 500 height = 500>
                    <figcaption>An 8 by 8 grid where every other row and every other column are walls.  The starting cell is in the upper left, and it has a neighbor to the right and a neighbor beneath.</figcaption>
                </figure>

                <p>
                    The algorithm randomly selects one of these unvisited neighbors and removes the wall between itself and that neighbor.  
                </p>


                <figure>
                    <img src="maze3.png" alt="A wall between a random, unvisited neighbor is removed" width = 500 height = 500>
                    <figcaption>A wall between a random, unvisited neighbor is removed</figcaption>
                </figure>

                <p>
                    The algorithm performs the same actions until it reaches a state where it doesn’t have any unvisitied neighbors. 
                </p>
            
                <figure>
                    <img src="maze8.png" alt="A cell has been reached with no remaining unvisited neighbors.  The neighbor above, below, and to the right have all been visited." width = 500 height = 500>
                    <figcaption>A cell has been reached with no remaining unvisited neighbors.  The neighbor above, below, and to the right have all been visited.</figcaption>
                </figure>

                <p>

                    The algorithm then goes back to the last cell which did have unvisited neighbors and continues this process.
                </p>

                <figure>
                    <img src="maze9.png" alt="The algorithm goes back to the last cell it visited which still has unvisited neighbors" width = 500 height = 500>
                    <figcaption>The algorithm goes back to the last cell it visited which still has unvisited neighbors</figcaption>
                </figure>

                <p>
                    The algorithm keeps going until all of the cells don’t have any unvisited neighbors.
                </p>

                <figure>
                    <img src="maze20.png" alt="All of the possible cells which didn't start out as walls have been visited and can be reached from the start.  The algorithm is over." width = 500 height = 500>
                    <figcaption>All of the possible cells which didn't start out as walls have been visited and can be reached from the start.  The algorithm is over.</figcaption>
                </figure>

                <p>
                    Finally, I want to add an exit to the maze so I remove the right most cell on the bottom row which is connected to an open cell.
                </p>

                <figure>
                    <img src="maze21.png" alt="Remove the wall in the cell which is furthest to the bottom right and also connected to an open cell" width = 500 height = 500>
                    <figcaption>Remove the wall in the cell which is furthest to the bottom right and also connected to an open cell</figcaption>
                </figure>

                <p>
                    Some examples of mazes generated from 20 by 20 grids are shown below:
                </p>

                <figure>
                    <img src="maze_example_1.png" alt="Example result of algorithm running on 20 by 20 grid" width = 500 height = 500>
                    <figcaption>Example result of algorithm running on 20 by 20 grid</figcaption>
                </figure>
                <figure>
                    <img src="maze_example_2.png" alt="Example result of algorithm running on 20 by 20 grid" width = 500 height = 500>
                    <figcaption>Example result of algorithm running on 20 by 20 grid</figcaption>
                </figure>

                </p>




            <h3>Particle Shooting</h3>
                <p>
                    Another problem I needed to resolve was particle shooting.  It was pretty easy to generate a particle from the user’s location and shoot in in the direction they were facing with a little randomness added.  However, in order to make the particle effective in helping the user navigate through the maze, they needed to stick to the walls, floor and ceiling.  The way I do this is by calculating the time it takes the particle to reach the nearest wall, the floor and the ceiling.  This gives three different numbers, and I return the smallest, non negative number.  This is because a negative number would mean the particle would have to travel in the opposite direction it is currently traveling, and the smallest positive number is the first furfase the particle crosses.  In each draw loop, I update how much longer each particle has left before it crosses its first collision point, and then I set the velocity of that particle to zero.  This gives the appearance that the particle is stuck where it is supposed to be.
                </p>

                <figure>
                    <img src="stick3.png" alt="Intuition behind how I get the particles to stick to the walls when they collide" width = 800 height = 450>
                    <figcaption>Intuition behind how I get the particles to stick to the walls when they collide</figcaption>
                </figure>

            <h3>User/Wall Collisions</h3>

                <p>
                    Initially, just like how the particles were able to travel through the walls of the maze, the user was also initially able to travel through the walls of the maze.  In order to prevent this, I determine if the user is close to a cell border.  If the two cells which make up the border are not actually wall cells, then the user can pass through as expected. 
                </p>

                <figure>
                    <img src="cellEdgeNowall.png" alt="Boundary between two cells.  Neither are wall cells so the user can pass through." width = 800 height = 450>
                    <figcaption>Boundary between two cells.  Neither are wall cells so the user can pass through.</figcaption>
                </figure>

                <p>
                    However, if one of the cells which make up the border is in fact a wall, then I only update the user’s position along the same axis the wall is aligned with.  
                </p>

                <figure>
                    <img src="cellEdge.png" alt="Boundar between two cells.  One of the cells is a wall so the user will not be able to pass through" width = 800 height = 450>
                    <figcaption>Boundar between two cells.  One of the cells is a wall so the user will not be able to pass through</figcaption>
                </figure>

                <p>
                    This prevents the user from phasing through walls when they are walking at normal speed, but if the user pressed the shift key to move fast, then there is a chance that they will be able to pass through the wall because they are never in the zone in which the collision detection algorithm tests for.

                </p>
        
        <h2>Computational Bottlenecks</h2>

                <p>
                    The biggest limiting factor on my game was the number of particles I was able to render.  All of the particles need to be kept in memory and rendered every frame, even when they are not in the actual gameplay window.  Specifically each particle is made up of verteces, so if I could reduce the number of vertices of each particle, I could render more particles. 

                    <br>
                    <br>

                    Initially I was using Processing’s built in sphere function.  Processing allows me to set the detail level of the spheres, and the default was 30.  These spheres look how one would expect a sphere to look as shown below:
                </p>

                <figure>
                    <img src="30sphere.png" alt="Result of using Processing’s sphere built in function with a detail level of 30" width = 800 height = 450>
                    <figcaption>Result of using Processing’s sphere built in function with a detail level of 30.  Can only render about 400 before dropping below 30FPS</figcaption>
                </figure>

                <p>
                    However, I didn’t really care how spherical the particles actually were, so I decided to change the detail level of the spheres to 1 to see if I could render more before dropping in frames per second.  The detail 1 spheres are shown below.  
                </p>


                <figure>
                    <img src="1sphere.png" alt="Result of using Processing’s sphere built in function with a detail level of 1" width = 800 height = 450>
                    <figcaption>Result of using Processing’s sphere built in function with a detail level of 1.  Can render about 40,000 before dropping below 30 FPS</figcaption>
                </figure>

                <p>
                    As you can see, these don’t look as much like spheres as the detail 30 spheres, but I was able to render about 40,000 spheres using detail level of 1 and only about 400 detail level 30 spheres before by frames per second dropped below 30.  I also decided to try processing’s box built in function.  The result of these particles is shown below:
                </p>


                <figure>
                    <img src="boxes.png" alt="Result of using processing’s box built in function." width = 800 height = 450>
                    <figcaption>Result of using processing’s box built in function. Can render about 25,000 before dropping below 30 fps</figcaption>
                </figure>

                <p>
                    However, using this method resulted in being able to render 25,000 particles before dropping to 30 FPS.  The final method I attempted was to generate manual tetrahedrons which is the polyhedron with the least amount of vertices.  Using this method resulted in particles looking like this:
                </p>


                <figure>
                    <img src="tets.png" alt="Result of using my own, manually built tetrahedrons" width = 800 height = 450>
                    <figcaption>Result of using my own, manually built tetrahedrons.  Can render about 60,000 before dropping below 30 fps.</figcaption>
                </figure>

                <p>
                    This performed better than detail 1 spheres because I was able to render 60,000 particles before dropping below 30 FPS.  I didn’t care how the particles looked, so I decided to use the tetrahedrons as they were the most efficient.  The only thing I cared about was being able to render the maximum number of particles possible before having to delete the oldest ones to make space for the new ones.  
                </p>

        <h2>Feedback</h2>

        <h2>State of the Art</h2>

        <h2>Future Work</h2>
            <p>I mentioned some suggestions I received from peers which I didn’t implement.  Specifically, I’m talking about introducing monsters to the game which would try to catch the user.  One thing I would have to change in order to implement this is to change the way the maze is generated.  With the current maze generation algorithm, if the user got stuck in a dead end, and a monster cornered the user, there would be no way for the user to escape because my algorithm doesn’t produce any loops in the maze.  There would have to be a good balance between the amount of loops in the maze and the number of dead ends, because if there are too many loops then the user would be able to make thier way to the bottom right of the maze pretty easy. 
                
                <br>
                <br>
                
                Another idea I received was to introduce a timer, or a counter of how many particles the user needed to use to complete the maze.  It would be fun to have a scoreboard of people who were able to complete a maze the fastest or with the least amount of particles.  This also gets tricky because the maze is different each time, so one user might have a really easy maze, and another user might have a really hard maze. 
                </p>

        <h2>Code</h2>
            <a href="https://docs.google.com/document/d/1Tzeb0b7iyrHF-VJTIcLeHnhjVUSonFjCiHa1-r6Ze4A/edit?usp=sharing">Simulation</a><br>
            <a href="https://docs.google.com/document/d/1J--E6NEYinui_4GOEZ3GjSyyFvBqJY3x2fDtqlDnmbI/edit?usp=sharing">Maze Class</a><br>
            <a href="https://docs.google.com/document/d/1S9N4h2qoIyQEXu9ZN4S-Fm8mdyV4sMy6aaTKPcU3ooU/edit?usp=sharing">MazeCell Class</a><br>
            <a href="https://docs.google.com/document/d/17YLTFHtnxf0xuPpef_jZHxO3kMRZwsCc5WwN2917hJQ/edit?usp=sharing">Camera Class</a><br>


    </body>
</html>